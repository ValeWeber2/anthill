use crate::{
    proc_gen::bsp::PADDING,
    world::{
        coordinate_system::Point,
        level_data::RoomData,
        worldspace::{Room, WORLD_HEIGHT, WORLD_WIDTH},
    },
};

/// Id used for [MapNode]s.
pub type NodeId = usize;

/// A `MapNode` is a node in a binary search partition (BSP) tree.
///
/// The worldspace is generated by using a binary search partition algorithm to divide it into smaller cells (represented as nodes in the tree).
/// The leaves of this tree will become the final rooms on the map.
///
/// # Note
/// This data structure is not a nested tree structure. Instead of nesting other `MapNode`s, only an ID is saved for child nodes.
/// A linear list structure with id references was chosen because rust struggles with recursive data structures.
#[derive(Clone, Debug)]
pub struct MapBSPNode {
    /// Point of origin (top left) of the room.
    pub point_a: Point,

    /// Point of the end (bottom right) of the room.
    pub point_b: Point,

    /// Contains the id of the child node (if any). Due to the nature of binary search partition, a given node always has either 0 or 2 child nodes, never 1.
    pub left: Option<NodeId>,

    /// Contains the id of the child node (if any). Due to the nature of binary search partition, a given node always has either 0 or 2 child nodes, never 1.
    pub right: Option<NodeId>,
}

impl MapBSPNode {
    pub fn new(point_a: Point, point_b: Point) -> Self {
        Self { point_a, point_b, left: None, right: None }
    }

    /// Helper function to determine whether a given node is a leaf.
    pub fn is_leaf(&self) -> bool {
        self.left.is_none() && self.right.is_none()
    }
}

impl Default for MapBSPNode {
    /// A default node always encompasses the entire available worldspace. This is the parent node in the tree that will be subdivided in the BSP algorithm.
    fn default() -> Self {
        Self {
            point_a: Point::new(PADDING, PADDING), // Leaves 2 tile-wide padding as to not encroach upon the border.
            point_b: Point::new(WORLD_WIDTH - PADDING, WORLD_HEIGHT - PADDING),
            left: None,
            right: None,
        }
    }
}

// To convert a MapNode (BSP data structure) into a Room (data structure used by the game to carve rooms into the void)
impl From<MapBSPNode> for Room {
    fn from(value: MapBSPNode) -> Self {
        let dimensions = value.point_b - value.point_a;
        Room::new(value.point_a, dimensions.x as usize, dimensions.y as usize)
    }
}

// To convert a MapNode (BSP data structure) into RoomData (data structure used by the world save files)
impl From<MapBSPNode> for RoomData {
    fn from(value: MapBSPNode) -> Self {
        let dimensions = value.point_b - value.point_a;
        RoomData {
            x: value.point_a.x,
            y: value.point_a.y,
            width: dimensions.x as usize,
            height: dimensions.y as usize,
        }
    }
}
