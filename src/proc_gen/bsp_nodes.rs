use std::cmp;

use rand::Rng;

use crate::{
    proc_gen::bsp::{GRID_SIZE, MIN_NODE_DIM_SHRUNK, PADDING, SHRINK_FACTOR_RANGE},
    world::{
        coordinate_system::{Point, PointVector},
        world_data::RoomData,
        worldspace::{Room, WORLD_HEIGHT, WORLD_WIDTH},
    },
};

/// Id used for [MapNode]s.
pub type NodeId = usize;

/// A `MapNode` is a node in a binary search partition (BSP) tree.
///
/// The worldspace is generated by using a binary search partition algorithm to divide it into smaller cells (represented as nodes in the tree).
/// The leaves of this tree will become the final rooms on the map.
///
/// # Note
/// This data structure is not a nested tree structure. Instead of nesting other `MapNode`s, only an ID is saved for child nodes.
/// A linear list structure with id references was chosen because rust struggles with recursive data structures.
#[derive(Clone, Debug)]
pub struct MapNode {
    /// Point of origin (top left) of the room.
    pub point_a: Point,

    /// Point of the end (bottom right) of the room.
    pub point_b: Point,

    /// Contains the id of the child node (if any). Due to the nature of binary search partition, a given node always has either 0 or 2 child nodes, never 1.
    pub left: Option<NodeId>,

    /// Contains the id of the child node (if any). Due to the nature of binary search partition, a given node always has either 0 or 2 child nodes, never 1.
    pub right: Option<NodeId>,
}

impl MapNode {
    pub fn new(point_a: Point, point_b: Point) -> Self {
        Self { point_a, point_b, left: None, right: None }
    }

    /// Helper function to determine whether a given node is a leaf.
    pub fn is_leaf(&self) -> bool {
        self.left.is_none() && self.right.is_none()
    }

    pub fn shrink<R: Rng + ?Sized>(&mut self, rng: &mut R) {
        let width = self.point_b.x - self.point_a.x;
        let height = self.point_b.y - self.point_a.y;

        // Shrunk width
        let new_width = shrink_dimension(width, rng.random_range(SHRINK_FACTOR_RANGE));
        // Shrunk height. Max 1.5 times as large as the width. This avoids weird long rooms (due to terminal grid not being 1:1)
        let new_height = cmp::min(
            shrink_dimension(height, rng.random_range(SHRINK_FACTOR_RANGE)),
            (new_width as f32 * 1.5) as usize,
        );

        self.point_a.x += (width.saturating_sub(new_width)) / 2;
        self.point_b.x -= (width.saturating_sub(new_width)) / 2;
        self.point_a.y += (height.saturating_sub(new_height)) / 2;
        self.point_b.y -= (height.saturating_sub(new_height)) / 2;
    }

    pub fn get_floor_points(&mut self) -> Vec<Point> {
        let mut points: Vec<Point> = Vec::new();

        let x_range = (self.point_a.x + GRID_SIZE)..(self.point_b.x - GRID_SIZE);
        let y_range = (self.point_a.y + GRID_SIZE)..(self.point_b.y - GRID_SIZE);

        for x in x_range {
            for y in y_range.clone() {
                points.push(Point::new(x, y));
            }
        }

        points
    }

    pub fn center(&self) -> Point {
        let dimensions: PointVector = self.point_b - self.point_a;
        self.point_a + dimensions.map(|n| n / 2)
    }
}

/// Helper function to shrink dimensions of a room (height or width).
///
/// Gives the room 1 layer of padding first and then shrinks it relatively. Cannot shrink further than the [MIN_NODE_DIM_SHRUNK]
fn shrink_dimension(dimension: usize, factor: f32) -> usize {
    let padded = dimension.saturating_sub(2);
    let shrunken = (padded as f32 * factor) as usize;

    cmp::max(MIN_NODE_DIM_SHRUNK, shrunken)
}

impl Default for MapNode {
    /// A default node always encompasses the entire available worldspace. This is the parent node in the tree that will be subdivided in the BSP algorithm.
    fn default() -> Self {
        Self {
            point_a: Point::new(PADDING, PADDING), // Leaves 2 tile-wide padding as to not encroach upon the border.
            point_b: Point::new(WORLD_WIDTH - PADDING, WORLD_HEIGHT - PADDING),
            left: None,
            right: None,
        }
    }
}

// To convert a MapNode (BSP data structure) into a Room (data structure used by the game to carve rooms into the void)
impl From<MapNode> for Room {
    fn from(value: MapNode) -> Self {
        let dimensions = value.point_b - value.point_a;
        Room::new(value.point_a, dimensions.x as usize, dimensions.y as usize)
    }
}

// To convert a MapNode (BSP data structure) into RoomData (data structure used by the world save files)
impl From<MapNode> for RoomData {
    fn from(value: MapNode) -> Self {
        let dimensions = value.point_b - value.point_a;
        RoomData {
            x: value.point_a.x,
            y: value.point_a.y,
            width: dimensions.x as usize,
            height: dimensions.y as usize,
        }
    }
}
