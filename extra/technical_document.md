# Anthill - Technical Document
_Anthill_ is a game developed as part of the module "Pracical Course on Software Development".

The game is a Rogue-like, taking after the original _Rogue_, which was a game played in a Terminal User Interface with procedurally generated levels, which the players would explore. A core tenet of Rogue-likes is having to start over after reaching Game Over, hoping for a better string of luck in your next "run".

## Overview
- Terminal User Interface
- Procedural level generation
- Fog of War and Field of View rendering
- NPC AI system
- A game system for combat and stats
- Level loader that loads handmade levels from disk
- In-Game command console
- Seeded RNG engine
- Comprehensive game-logging
- Keyboard Controls
- Detailed code documentation

## Architecture
- Central **Game State** struct, which owns all the game's data. Core systems are implemented as methods on game state. Sub-components of the game state only have access to their localized abstraction layer, while the game state enforces the games rules and manages the data communication (Demeter's Law).
- A **turn-based Game Loop**. Being a turn-based game in a TUI, the app's state only updates on player input. Player input is turned into an Action Enum, which is resovled centrally by the game state.
- **Cleanly separated UI logic**, allowing the possibility to create a headless version or a different UI in the future (inspired by NetHack)
- The game involves exploring multiple **Levels**, which each own their respective data.
- An **coordinate system** which safely abstracts coordinate implementations through Points, Vectors, and Directions.
- A centralised **ID system** ensuring unique ids for all entities.
- A centralized, seeded **RNG instance** stored in the game state (created with a random seed in the production version)
- Conditional compilation of production/development features.
- Logging of the game engine's events to a file in the user's data folder.

## World
The world consists of multiple **Levels**.

- Each level owns...
    - its **World**, which is stored as a 1-dimensional array of Tiles.
    - its **non-player-characters**
    - its **item-sprites** which are interactable entities of items lying around to be collected.
        - **Items** are not owned by the level, but by the game state, since they persist between levels (e.g. the player picks them up and keeps them in their inventory)
- **Tiles** the spaces on the 150x25 grid of terminal characters. Each character represents 1 tile.
    - Interactions with tiles (e.g. collision, visibility) are tested with Rust traits.

### LevelData
The `Level` struct contains the state of the current game at the current level at runtime. It owns the Npcs and Item sprites and the World. The game state accesses the current level by borrowing it through a getter. So mutations of level state always happen through `GameState::current_level_mut()` or `GameState::current_world_mut()`.

As an abstraction, `LevelData` exists, which contains a blueprint to build a `Level`. It does not contain a world, npcs, and item sprites, but abstracted patterns to create them.

- Example 1: `LevelData` contains `RoomData`, which represents the geometric shape of a room, which, upon loading, is used to draw floor and wall tiles.
- Example 2: `LevelData` contains `SpawnData`, detailling what kind of NPC to spawn at which location.

`LevelData` is used for creating the handmade `level.ron` files. `LevelData` is also what is generated by the procedural generation algorithms.

### Procedural Generation
The **ProcGen Rng Instance** is independent from the main rng instance, meaning that player input doesn't change world generation. This instance is sourced for seeds for each level that is procedurally generated

Procedural level generation sequence:
1. The available space is divided using a *Binary Search Partitioning* (BSP) algorithm.
2. The leaves of the BSP tree are what will become the level's rooms
3. Each of the rooms is shrunk (so they don't touch and to create the shape of a dungeon)
4. A minimum spanning tree is created between the rooms using a *UnionFind* data structure and *Kruskal's Algorithm*. Additional random connections are added to the minimum spanning tree for more corridors.
5. A *weighted A\* Algorithm* is used for generating the shape of the corridor.
6. Each of the rooms is assigned an "Encounter", determining what entities to spawn and special tiles to place.
7. Randomly selected entities (npcs + items) are placed at available tiles in each room.

## Game Mechanics
The player updates the state of the game through **Actions**, which are specific things the player character does each turn in the game (e.g. move, attack, eat).

From player input, the corresponding action is assigned depending on the context. Many actions (move, attack, pick up item, interact with tile) are done through a directional input (Example: An enemy is directly north of the player. The player presses W on the keyboard. Normally, they would move north, but in this case, they attack the enemy instead.)

### NPC AI
Non-player characters have an AI state (a finite state-machine), which dictates what they do. Normally, they wander in a random direction. If they make contact with the player, they will switch to an aggressive AI state, making them chase the player (pathfinding through a *weighted A\* algorithm* calculated each turn) and attack them when in range.

### Item System
Items themselves are stored in an item register in the game state. This means they are persistent between levels and can be de-registered, dropping them from memory.

Any instances of items reference the id in the register. The player's inventory and item sprites in the world just reference this id.

The player can collect up to 26 items. When they open the inventory, selecting an item "uses" it. The effect depends on the item type.

- Weapon: Use it to equip it to the weapon slot.
- Armor: Use it to equip it to the armor slot.
- Food: Use it to consume it.
- Potion: Use it to consume it.


### Command Promopt
The user can open a command prompt with a variety of commands to interact with the game. Most commands are either cheat codes or debugging tools. A list of commands can be found in the game's guide or by entering `help`.

## UI
The UI is a Terminal User Interface created with the *ratatui* crate. It has multiple components.

- **World**: Displays the tiles and entities in the world.
- **Menu**: Displays the game's logs and additional menus like inventory.
- **Info**: Displays information about the player character.
- **Modals**: Are pop-up windows which are used for prompting the user

The UI also has other modes in which the main game UI is not displayed.

Because the game's world is a fixed size (100x25), the TUI responsively keeps it the same size and centers it regardless of window dimensions. All other components also responsively adapt to screen size.

### User Experence Features
If window dimensions/resolution are not sufficient to display the world, a warning is displayed instead of the game, telling the user how to change it.

The **Game Log** displays the narration of the most recent events in the game. Key words are highlighted in colors for better comprehension.

The **Info** display gives the player up-to-date information about their character and related game statistics, so the character understands the game's numbers. If health is critical, the Hit Points are colored red.

A **Help Pop Up** can be opened with a hotkey, explaining all the game's controls and commands.

## Testing
The main testing process consists of playtesting. Testers are given a build of the game to provide feedback on. In a feedback form, they can provide feedback on our design decisions. In a separate bug submission form, they can report problems with the game.

The playtesting process is documented and discussed. See [playtest_report](./playtest_report.md).

## Non-Functional Features
### Error Handling Strategy
Errors in the game are represented by a custom `GameError` type, which differentiates between
- `EngineError` The game's core engine encountered a state that cannot be represented.
- `DataError` The game's data is missing or faulty.
- `IoError` Normal IO Errors.

Another custom type, `GameOutcome`, was built that doesn't represent features in the game that can succeed or fail *as part of the rules of the game* (e.g. not being allowed to walk onto a tile that is a wall). These are handled by the game itself and don't cause errors.

`GameResult` is a type that combines the two as `Result<GameOutcome, GameError>` and is used often to handle the ternary effects of game features:
1. There is an error in the game and the effect cannot be completed: `Err(GameError)`
2. This effect is not allowed by the game's rules and cannot be completed: `Ok(GameOutcome::Fail(FailReason:...))`
3. This effect was successful `Ok(GameOutcome::Success)`

As user inputs are what updates the game, errors are handled either immediately or passed up and handled by the input handler. User inputs do not cause panics.

Unwraps and other panicking functions are not used except in deliberate scenarios where the game cannot continue, such as a level.ron file being corrupted.

### Documentation
The game's code is documented in detail using rustdoc. To view the documentation, run:

```bash
cargo doc
```

### Quality
- The game was written in a devcontainer using Docker and VSCode's devcontainer API.
- Cargo Fmt and Cargo Clippy were used as server-side quality gates.
- Larger new features were all developed in separate branches.
- Release versions were all developed in separate branches.
- Branches were reviewed and merged in weekly meetings.
- No unsafe rust code was necessary.